# Initialize default values
$c = $configuration | ConvertFrom-Json
$p = $person | ConvertFrom-Json
$success = $false # Set to false at start, at the end, only when no error occurs it is set to true
$auditLogs = [System.Collections.Generic.List[PSCustomObject]]::new()

# Set TLS to accept TLS, TLS 1.1 and TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls -bor [Net.SecurityProtocolType]::Tls11 -bor [Net.SecurityProtocolType]::Tls12

# Set debug logging
switch ($($c.isDebug)) {
    $true { $VerbosePreference = 'Continue' }
    $false { $VerbosePreference = 'SilentlyContinue' }
}
$InformationPreference = "Continue"
$WarningPreference = "Continue"

# Used to connect to Azure AD Graph API
$AADtenantID = $c.AADtenantID
$AADAppId = $c.AADAppId
$AADAppSecret = $c.AADAppSecret

# Use dummy reference for previews
if($dryRun -eq $true){
    $aRef = "Test-Reference"
}

# Initialize Account Object (For Notifications)

$account = [PSCustomObject]@{
    UPN = $null
    NickName = $null
    Password = $null
    Title = $null
    Department = $null
};

# Fetch password from password generator (or dummy value for previews)
if(-Not($dryRun -eq $true)){
    $account.password = $p.Accounts.AzureADStaffPasswordGener.Password
}else{
    $account.password = $p.Accounts.AzureADStaffPasswordGener.Password
}

#region functions

# Generate Azure AD Authorization Headers
function New-AuthorizationHeaders {
    [CmdletBinding()]
    [OutputType([System.Collections.Generic.Dictionary[[String], [String]]])]
    param(
        [parameter(Mandatory)]
        [string]
        $TenantId,

        [parameter(Mandatory)]
        [string]
        $ClientId,

        [parameter(Mandatory)]
        [string]
        $ClientSecret
    )
    try {
        Write-Verbose "Creating Access Token"
        $baseUri = "https://login.microsoftonline.com/"
        $authUri = $baseUri + "$TenantId/oauth2/token"
    
        $body = @{
            grant_type    = "client_credentials"
            client_id     = "$ClientId"
            client_secret = "$ClientSecret"
            resource      = "https://graph.microsoft.com"
        }
    
        $Response = Invoke-RestMethod -Method POST -Uri $authUri -Body $body -ContentType 'application/x-www-form-urlencoded'
        $accessToken = $Response.access_token
    
        #Add the authorization header to the request
        Write-Verbose 'Adding Authorization headers'

        $headers = [System.Collections.Generic.Dictionary[[String], [String]]]::new()
        $headers.Add('Authorization', "Bearer $accesstoken")
        $headers.Add('Accept', 'application/json')
        $headers.Add('Content-Type', 'application/json')
        # Needed to filter on specific attributes (https://docs.microsoft.com/en-us/graph/aad-advanced-queries)
        $headers.Add('ConsistencyLevel', 'eventual')

        Write-Output $headers  
    }
    catch {
        $PSCmdlet.ThrowTerminatingError($_)
    }
}

# Resolve General HTTP Errors
function Resolve-HTTPError {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory,
            ValueFromPipeline
        )]
        [object]$ErrorObject
    )
    process {
        $httpErrorObj = [PSCustomObject]@{
            FullyQualifiedErrorId = $ErrorObject.FullyQualifiedErrorId
            MyCommand             = $ErrorObject.InvocationInfo.MyCommand
            RequestUri            = $ErrorObject.TargetObject.RequestUri
            ScriptStackTrace      = $ErrorObject.ScriptStackTrace
            ErrorMessage          = ''
        }
        if ($ErrorObject.Exception.GetType().FullName -eq 'Microsoft.PowerShell.Commands.HttpResponseException') {
            $httpErrorObj.ErrorMessage = $ErrorObject.ErrorDetails.Message
        }
        elseif ($ErrorObject.Exception.GetType().FullName -eq 'System.Net.WebException') {
            $httpErrorObj.ErrorMessage = [System.IO.StreamReader]::new($ErrorObject.Exception.Response.GetResponseStream()).ReadToEnd()
        }
        Write-Output $httpErrorObj
    }
}

# Resolve Azure-Specific HTTP Errors
function Resolve-MicrosoftGraphAPIErrorMessage {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory,
            ValueFromPipeline
        )]
        [object]$ErrorObject
    )
    process {
        try {
            $errorObjectConverted = $ErrorObject | ConvertFrom-Json -ErrorAction Stop

            if ($null -ne $errorObjectConverted.error_description) {
                $errorMessage = $errorObjectConverted.error_description
            }
            elseif ($null -ne $errorObjectConverted.error) {
                if ($null -ne $errorObjectConverted.error.message) {
                    $errorMessage = $errorObjectConverted.error.message
                    if ($null -ne $errorObjectConverted.error.code) { 
                        $errorMessage = $errorMessage + " Error code: $($errorObjectConverted.error.code)"
                    }
                }
                else {
                    $errorMessage = $errorObjectConverted.error
                }
            }
            else {
                $errorMessage = $ErrorObject
            }
        }
        catch {
            $errorMessage = $ErrorObject
        }

        Write-Output $errorMessage
    }
}

# Sanitization function for names
function get-sanitizedUTF8Input{
    Param(
        [String]$inputString
    )
    $replaceTable = @{"ß"="ss";"à"="a";"á"="a";"â"="a";"ã"="a";"ä"="a";"å"="a";"æ"="ae";"ç"="c";"ć"="c";"è"="e";"é"="e";"ê"="e";"ë"="e";"ì"="i";"í"="i";"î"="i";"ï"="i";"ð"="d";"ñ"="n";"ò"="o";"ó"="o";"ô"="o";"õ"="o";"ö"="o";"ø"="o";"ṡ"="s";"ṣ"="s";"ṥ"="s";"ṧ"="s";"ṩ"="s";"š"="s";"ù"="u";"ú"="u";"û"="u";"ü"="u";"ý"="y";"þ"="p";"ÿ"="y";"ž"="z"}

    foreach($key in $replaceTable.Keys){
        $inputString = $inputString -Replace($key,$replaceTable.$key)
    }
    $inputString = $inputString -replace '[^a-zA-Z]', ''
    return $inputString
}

# Generate Azure Account Identifiers
#
# Nickname Format: [firstInitial][lastName][Iterative Suffix (02..03..)]
# Mail/UPN Format: nickname@[domain]
function Get-Username{
    [cmdletbinding()]
    Param (
        [string]$firstName,
        [string]$lastName,
        [string]$azureUri,
        [string]$currentAzureID,
        [PSCustomObject]$azureHeaders
    )
    Process{
        try{
            $iterationEnd = 9
            $iterationStart = 0;

            # Get Clean First Name
            $firstName = get-sanitizedUTF8Input -inputString $firstName
            $firstName = $firstName -replace '[^a-zA-Z]', ''

            # Get First Initial
            $firstInitial = $firstName.substring(0, 1); 

            # Get Clean Last Name
            $lastName = get-sanitizedUTF8Input -inputString $lastName;
            $lastName = $lastName -replace '[^a-zA-Z]', ''

            # Generate unique username with iteration (10 iterations at most)
            for($i = $iterationStart; $i -lt $iterationEnd; $i++){
                
                # Maintain iteration suffix
                $suffix = ""; 

                # Use 64-character limit as max
                $maxAttributeLength = 64; 

                # Generate Suffix
                if($i -gt 0){
                    $newIteration = $i.ToString(); 
                    $suffix = $newIteration; 
                }

                # Generate Username Max Length
                $maxAttributeLength = $maxAttributeLength - ($suffix.Length); 

                # Combine first initial and last name
                $nickname = $firstInitial + $lastName;
                
                # Force lowercase the username
                $nickname = $nickname.ToLower();
                
                # Restrict username to max number of characters 
                if($nickname.Length -gt $maxAttributeLength){
                    $nickname = $nickname.substring(0,$maxAttributeLength)
                }

                # Add iteration suffix
                $nickname = $nickname + $suffix; 

                # Calculate UPN and MAIL
                $upn = $nickname + "@" + $c.azureDomain;
                $mail = $nickname + "@" + $c.azureDomain;

                # Check Account Identifiers Against Azure AD

                # Check mailNickname Field

                $searchUri = $azureUri + "v1.0/users?`$filter=mailNickname eq '$($nickname)'"
                $response = Invoke-RestMethod -Uri $searchUri -Method Get -Headers $azureHeaders -Verbose:$false
                $duplicateNicknames = $response.value;

                # Check mail Field

                $searchUri = $azureUri + "v1.0/users?`$filter=mail eq '$($mail)'"
                $response = Invoke-RestMethod -Uri $searchUri -Method Get -Headers $azureHeaders -Verbose:$false
                $duplicateMails = $response.value;
    
                # Check userPrincipalName Field

                $searchUri = $azureUri + "v1.0/users?`$filter=userPrincipalName eq '$($mail)'"
                $response = Invoke-RestMethod -Uri $searchUri -Method Get -Headers $azureHeaders -Verbose:$false
                $duplicateUPNs = $response.value;

                # Check proxyAddresses Field

                $searchUri = $azureUri + "v1.0/users?`$filter=proxyAddresses/any(p:p eq 'smtp:$($mail)')"
                $response = Invoke-RestMethod -Uri $searchUri -Method Get -Headers $azureHeaders -Verbose:$false
                $duplicateProxies = $response.value;

                # Filter out existing account (if any)
                if($currentAzureID -ne $null){
                    $duplicateNicknames = $duplicateNicknames | ?{$_.id -ne $currentAzureID}
                    $duplicateMails = $duplicateMails | ?{$_.id -ne $currentAzureID}
                    $duplicateUPNs = $duplicateUPNs | ?{$_.id -ne $currentAzureID}
                    $duplicateProxies = $duplicateProxies | ?{$_.id -ne $currentAzureID}
                }

                $conflictCount = 0;
                $conflictCount += $duplicateNicknames.Length;
                $conflictCount += $duplicateMails.Length; 
                $conflictCount += $duplicateUPNs.Length; 
                $conflictCount += $duplicateProxies.Length; 

                # If calculated identifiers are unique, use them
                if(($conflictCount -eq 0)){
                    $returnObject = @{mailNickname=$nickname; userPrincipalName=$upn; mail=$mail;}
                    Write-Information "Using mailNickname: $($nickname)"; 
                    Write-Information "Using mail: $($mail)";
                    Write-Information "Using userPrincipalName: $($upn)";
                    break;

                # If we have exceeded the number of iterations, throw an error
                }elseif($i -eq ($iterationEnd - 1)){
                    throw "Uniqueness Check Exceeded Max Iterations..."
                # If calculated identifiers are not unique,
                # iterate and generate new ones
                }else{
                    Write-information "Duplicates found. Iterating...";
                }
            }

            return $returnObject
        }catch{
            Write-error "Error generating names. Error: $($_.Exception.Message)"
        }
    }
}

function Get-LatestContractProperty {
    param (
        [Parameter(Mandatory = $true)]
        [array]$contracts,

        [Parameter(Mandatory = $true)]
        [string]$propertyPath
    )

    # Initialize variables
    $latestStartDate = [datetime]::MinValue
    $latestContract = $null
    $today = [datetime]::Today
    $i = 0

    # Loop through contracts to find the latest start date with non-null property value and no EndDate
    foreach ($contract in $contracts) {
        $startDate = if ($contract.StartDate) { [datetime]::Parse($contract.StartDate) } else { [datetime]::MinValue }
        $endDate = if ($contract.EndDate) { [datetime]::Parse($contract.EndDate) } else { [datetime]::MinValue }

        # Check conditions: Latest start date, non-null property value, and no EndDate
        if ($startDate -le $today -and $startDate -gt $latestStartDate -and
            -not [string]::IsNullOrEmpty($contract.Custom.$propertyPath) -and
            [string]::IsNullOrEmpty($contract.EndDate) -or $endDate -gt $today) {

            $latestStartDate = $startDate
            $latestContract = $contract
        }
    }

    # Return the property value from the latest contract if found
    if ($latestContract -ne $null) {
        return $latestContract.Custom.$propertyPath
    } else {
        return $null
    }
}

$department = Get-LatestContractProperty -contracts $p.Contracts -propertyPath "department"
$location = Get-LatestContractProperty -contracts $p.Contracts -propertyPath "location"
$jobTitle = Get-LatestContractProperty -contracts $p.Contracts -propertyPath "title"
<#
#department
$i = 0
$department = $p.Contracts[0].Custom.department
do {
    if ([string]::IsNullOrEmpty($department)) {
        $department = $p.Contracts[$i].Custom.department
        $i++
    }
} while ([string]::IsNullOrEmpty($department) -and $i -lt 20)

#jobTitle
$i = 0
$jobTitle = $p.Contracts[0].Custom.title
do {
    if ([string]::IsNullOrEmpty($jobTitle)) {
        $jobTitle = $p.Contracts[$i].Custom.title
        $i++
    }
} while ([string]::IsNullOrEmpty($jobTitle) -and $i -lt 20)
#location
$i = 0
$location = $p.Contracts[0].Custom.location
do {
    if ([string]::IsNullOrEmpty($location)) {
        $location = $p.Contracts[$i].Custom.location
        $i++
    }
} while ([string]::IsNullOrEmpty($location) -and $i -lt 20)
#>
#endregion functions
try {
    # GET HELLOID UNIQUE ID

    $employeeID = $p.ExternalId; 

    # GET CURRENT AZURE AD ACCOUNT USING GRAPH FILTER

    # Generate Azure Headers
    $headers = New-AuthorizationHeaders -TenantId $AADtenantID -ClientId $AADAppId -ClientSecret $AADAppSecret
    
    Write-Verbose -Verbose "Querying Azure AD account with ID: [$($employeeID)]"
    
    # Build request
    $baseUri = "https://graph.microsoft.com/"
    $splatWebRequest = @{
        Uri     = "$baseUri/v1.0/users?`$select=id,mailNickName,userPrincipalName&`$filter=employeeID eq '$($employeeID)'"
        Headers = $headers
        Method  = 'GET'
    }
    
    # Fetch user list using criteria and pull back a count of users
    $currentAccounts = Invoke-RestMethod @splatWebRequest -SkipHttpErrorCheck -Verbose:$false
    $currentAccounts = $currentAccounts.value; 
    $fetchedAccountCount = $currentAccounts.Count; 

    # CHECK STATUS OF FILTER

    # IF ACCOUNT CANNOT BE FOUND, CREATE IT
    if($fetchedAccountCount -eq 0){

        $auditLogs.Add([PSCustomObject]@{
            Action  = "CreateAccount"
            Message = "Could not correlate to an Azure AD account using EmployeeID: [$($employeeID)]. A new account will be generated."
            IsError = $false
        })

        # Get First/Last Name
        $firstName = $p.Name.NickName;
        $lastName = if([string]::IsNullOrEmpty($p.Custom.lastName)) { $p.Name.FamilyName + $p.Custom.FamilyNamePartner } else { $p.Custom.lastName };
        $fullLastName = $p.Custom.fullLastName 
        # Get Password
        $accountPassword = $account.password;

        # Generate Unique Usernames (mail, mailNickname, and UPN)
        $usernames = Get-Username -firstName $firstName -lastName $lastName -azureUri $baseUri -azureHeaders $headers;

        # Prepare fields for new account
        $accountFields = [PSCustomObject]@{
            accountEnabled = $false
            mailNickname = $usernames.mailNickname
            mail = $usernames.mail
            userPrincipalName = $usernames.userPrincipalName
            givenName = $firstName
            surname = $fullLastName
            displayName = "$($firstName) $($fullLastName)"
            companyName = "Seaford UFSD"
            department = $department
            employeeId = $p.ExternalId
            officeLocation = $location
            jobTitle = $jobTitle
            passwordProfile = [PSCustomObject]@{
                password = $accountPassword
                forceChangePasswordNextSignIn = $true
            }
        }

        # Log Azure Fields that are being populated
        $accountFields.PSObject.Properties | ForEach-Object {
            Write-Information "$($_.Name) - $($_.Value)"; 
        }

        # Add UPN/Nickname For Notifications

        $account.UPN = $usernames.userPrincipalName; 
        $account.Nickname = $usernames.mailNickname;
        $account.Title = $jobTitle;
        $account.Department = $department;

        # Create New Azure AD Account

        if(-Not($dryRun -eq $true)){

            $splatCreateWebRequest = @{
                Uri     = 'https://graph.microsoft.com/v1.0/users'
                Method  = 'POST'
                Body    = $accountFields | ConvertTo-Json -Depth 10
                Verbose = $false
                Headers = $headers
            }

            $newAccount = Invoke-RestMethod @splatCreateWebRequest;
            
            # Store Account ID for system reference
            $aRef = $newAccount.id; 
        }

        $auditLogs.Add([PSCustomObject]@{
            Action  = "CreateAccount"
            Message = "Successfully created Azure AD account: [$($accountFields.userPrincipalName)]"
            IsError = $false
        })
    # IF ACCOUNT CAN BE FOUND, CORRELATE TO IT
    }elseif($fetchedAccountCount -eq 1){
        
        $newAccount = $currentAccounts[0]; 

        # Get First/Last Name
        $firstName = $p.Name.NickName;
        $lastName = if([string]::IsNullOrEmpty($p.Custom.lastName)) { $p.Name.FamilyName + $p.Custom.FamilyNamePartner } else { $p.Custom.lastName };
        $fullLastName = $p.Custom.fullLastName 

        # Generate Unique Usernames (mail, mailNickname, and UPN)
        $usernames = Get-Username -firstName $firstName -lastName $lastName -azureUri $baseUri -azureHeaders $headers -currentAzureID $newAccount.id;

        # Prepare fields for new account
        $accountFields = [PSCustomObject]@{
            mailNickname = $usernames.mailNickname
            mail = $usernames.mail
            userPrincipalName = $usernames.userPrincipalName
            givenName = $firstName
            surname = $fullLastName
            displayName = "$($firstName) $($fullLastName)"
            companyName = "Seaford UFSD"
            department = $department
            officeLocation = $location
            jobTitle = $jobTitle
        }
        
        # Log Azure Fields that are being populated
        $accountFields.PSObject.Properties | ForEach-Object {
            Write-Information "$($_.Name) - $($_.Value)"; 
        }
        
        # Add UPN/Nickname For Notifications

        $account.UPN = $newAccount.userPrincipalName; 
        $account.Nickname = $newAccount.mailNickname;
        $account.Title = $jobTitle;
        $account.Department = $department;
        
        $auditLogs.Add([PSCustomObject]@{
            Action  = "CreateAccount"
            Message = "Successfully correlated to Azure AD account: [$($account.UPN)])] using EmployeeID: [$($employeeID)]"
            IsError = $false
        })
        
        $aRef = $newAccount.id; 

            $splatUpdateWebRequest = @{
                Uri     = "https://graph.microsoft.com/v1.0/users/$($aRef)"
                Method  = 'PATCH'
                Body    = $accountFields | ConvertTo-Json -Depth 10
                Verbose = $false
                Headers = $headers
            }

            $response = Invoke-RestMethod @splatUpdateWebRequest;
            
        $auditLogs.Add([PSCustomObject]@{
            Action  = "UpdateAccount"
            Message = "Successfully updated Azure AD account: [$($aRef)]"
            IsError = $false
        })
    # IF MORE THAN 1 ACCOUNT CAN BE FOUND, THROW AN ERROR
    }else{
        $auditLogs.Add([PSCustomObject]@{
            Action  = "CreateAccount"
            Message = "More than one user found with EmployeeID: [$($employeeID)]"
            IsError = $true
        })
    }
}catch{
    # Clean up error variables
    $verboseErrorMessage = $null
    $auditErrorMessage = $null

    $ex = $PSItem
    if ( $($ex.Exception.GetType().FullName -eq 'Microsoft.PowerShell.Commands.HttpResponseException') -or $($ex.Exception.GetType().FullName -eq 'System.Net.WebException')) {
        $errorObject = Resolve-HTTPError -Error $ex

        $verboseErrorMessage = $errorObject.ErrorMessage

        $auditErrorMessage = Resolve-MicrosoftGraphAPIErrorMessage -ErrorObject $errorObject.ErrorMessage
    }

    # If error message empty, fall back on $ex.Exception.Message
    if ([String]::IsNullOrEmpty($verboseErrorMessage)) {
        $verboseErrorMessage = $ex.Exception.Message
    }
    if ([String]::IsNullOrEmpty($auditErrorMessage)) {
        $auditErrorMessage = $ex.Exception.Message
    }

    Write-Verbose -verbose "Error at Line '$($ex.InvocationInfo.ScriptLineNumber)': $($ex.InvocationInfo.Line). Error: $($verboseErrorMessage)"

    $auditLogs.Add([PSCustomObject]@{
        Action  = "CreateAccount"
        Message = "Error querying/creating Azure AD account with ID: [$($employeeID)]. Error Message: $auditErrorMessage"
        IsError = $True
    })
}finally{
    # Check if auditLogs contains errors, if no errors are found, set success to true
    if (-NOT($auditLogs.IsError -contains $true)) {
        $success = $true
    }

    # Send results
    $result = [PSCustomObject]@{
        Success          = $success
        AccountReference = $aRef
        AuditLogs        = $auditLogs
        Account          = $account
        ExportData       = [PSCustomObject]@{
            Email = $account.UPN
            department = $accountFields.department
            title = $accountFields.jobTitle
        }
    }

    Write-Output ($result | ConvertTo-Json -Depth 10)
}
